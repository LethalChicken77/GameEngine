#version 450

struct Particle
{
    vec2 position;
    vec2 velocity;
    float sediment; // Sediment to pick up and deposit
};

layout(set = 0, binding = 0, r32f) uniform image2D heightMap;
layout(set = 0, binding = 1) uniform sampler2D heightMapSampler;

layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PushConstants
{
    // uint textureSize;
    uint numParticles;
    uint seed;

    int maxLifetime;
    float sedimentScale;
    float sedimentCapacity;
    float baseCapacity;
    float gravity;
    float friction;
} pushConstants;

uint hash(uint x) 
{
    x = ((x >> 16u) ^ x) * 0x45d9f3b;
    x = ((x >> 16u) ^ x) * 0x45d9f3b;
    x = (x >> 16u) ^ x;
    return x;
}

float random(uint seed) 
{
    return float(hash(seed)) / float(0xffffffffu);
}

void main()
{
    uint index = gl_GlobalInvocationID.x;
    uint seed = pushConstants.seed * pushConstants.numParticles + index;
    if(index >= pushConstants.numParticles)
        return;
    uint iterations = 1;
    ivec2 texSize = imageSize(heightMap);

    float ds = 0.0001;
    float dt = 0.1;

    Particle particle;
    particle.position = vec2(random(seed), random(seed + 100)) * float(texSize.x);
    particle.velocity = vec2(0.0, 0.0);
    particle.sediment = 0.0;
    bool endErosion = false;
    for(int i = 0; i < pushConstants.maxLifetime; i++)
    {
        if(particle.position.x < 0.0 || particle.position.y < 0.0 || particle.position.x >= texSize.x || particle.position.y >= texSize.y)
        {
            break;
        }
        
        float xFrac = particle.position.x - floor(particle.position.x);
        float yFrac = particle.position.y - floor(particle.position.y);
        
        vec2 texturePos = particle.position / float(texSize.x);
        vec2 texturePos00 = floor(particle.position) / float(texSize.x);
        vec2 texturePos10 = (floor(particle.position) + vec2(1, 0)) / float(texSize.x);
        vec2 texturePos01 = (floor(particle.position) + vec2(0, 1)) / float(texSize.x);
        vec2 texturePos11 = (floor(particle.position) + vec2(1, 1)) / float(texSize.x);
        float height = texture(heightMapSampler, texturePos).r;
        float height00 = imageLoad(heightMap, ivec2(texturePos00 * texSize.x)).r;
        float height10 = imageLoad(heightMap, ivec2(texturePos10 * texSize.x)).r;
        float height01 = imageLoad(heightMap, ivec2(texturePos01 * texSize.x)).r;
        float height11 = imageLoad(heightMap, ivec2(texturePos11 * texSize.x)).r;

        float dx = (height10 - height00) * (1.0 - yFrac) + (height11 - height01) * yFrac;
        float dy = (height01 - height00) * (1.0 - xFrac) + (height11 - height10) * xFrac;
        // float dx = (height10 - height00) * (1.0 - yFrac) + (height11 - height01) * yFrac;
        // float dy = (height01 - height00) * (1.0 - xFrac) + (height11 - height10) * xFrac;

        vec2 gradient = vec2(dx, dy);
        float lowestNeighbor = min(min(height00, height10), min(height01, height11));

        float speed = length(particle.velocity);
        

        float newHeight = 0;
        if(i == pushConstants.maxLifetime - 1)// || (speed < 0.001f && i > 5))
        {
            newHeight += particle.sediment;
            endErosion = true;
        }
        else
        {
            float effectiveCapacity = pushConstants.sedimentCapacity * (speed + pushConstants.baseCapacity);
            if(particle.sediment > effectiveCapacity || dot(particle.velocity, gradient) > 0.0)
            {
                float depositionAmount = particle.sediment - effectiveCapacity;
                depositionAmount = min(depositionAmount, particle.sediment);
                newHeight += depositionAmount;
            }
            else if(particle.sediment < effectiveCapacity)
            {
                float erosionAmount = effectiveCapacity - particle.sediment;
                erosionAmount = min(erosionAmount, height - lowestNeighbor);
                newHeight -= erosionAmount;
            }
        }
        
        newHeight *= pushConstants.sedimentScale;

        float w00 = (1.0 - xFrac) * (1.0 - yFrac);
        float w10 = xFrac * (1.0 - yFrac);
        float w01 = (1.0 - xFrac) * yFrac;
        float w11 = xFrac * yFrac;

        float newHeight00 = max(height00 + newHeight * w00, lowestNeighbor);
        float newHeight10 = max(height10 + newHeight * w10, lowestNeighbor);
        float newHeight01 = max(height01 + newHeight * w01, lowestNeighbor);
        float newHeight11 = max(height11 + newHeight * w11, lowestNeighbor);
        float actualChange = newHeight00 + newHeight10 + newHeight01 + newHeight11 
                            - height00 - height10 - height01 - height11;

        imageStore(heightMap, ivec2(texturePos00 * texSize.x), vec4(newHeight00, 0.0, 0.0, 0.0));
        imageStore(heightMap, ivec2(texturePos10 * texSize.x), vec4(newHeight10, 0.0, 0.0, 0.0));
        imageStore(heightMap, ivec2(texturePos01 * texSize.x), vec4(newHeight01, 0.0, 0.0, 0.0));
        imageStore(heightMap, ivec2(texturePos11 * texSize.x), vec4(newHeight11, 0.0, 0.0, 0.0));

        particle.sediment -= actualChange / pushConstants.sedimentScale;
        particle.sediment = max(particle.sediment, 0.0);

        if(particle.sediment < 0.0001f)
            break;

        particle.velocity *= (1.0 - pushConstants.friction); // Apply friction before updating velocity
        particle.velocity += gradient * pushConstants.gravity;
        if(length(particle.velocity) > 1)
        {
            particle.velocity = normalize(particle.velocity);
        }
        particle.position += particle.velocity * dt;
    }
}